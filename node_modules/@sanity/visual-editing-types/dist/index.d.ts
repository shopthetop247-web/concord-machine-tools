import { Path, StudioPathLike } from "@sanity/client/csm";
import { ArrayOptions, PreviewValue } from "@sanity/types";
/** @alpha This API may change */
declare interface InsertMenuOptions {
  /**
   * @defaultValue `'auto'`
   * `filter: 'auto'` automatically turns on filtering if there are more than 5
   * schema types added to the menu.
   */
  filter?: "auto" | boolean | undefined;
  groups?: Array<{
    name: string;
    title?: string;
    of?: Array<string>;
  }> | undefined;
  /** defaultValue `true` */
  showIcons?: boolean | undefined;
  /** @defaultValue `[{name: 'list'}]` */
  views?: Array<{
    name: "list";
  } | {
    name: "grid";
    previewImageUrl?: (schemaTypeName: string) => string | undefined;
  }> | undefined;
}
/**
 * Data resolved from a Sanity node
 * @public
 */
type SanityNode = {
  baseUrl: string;
  id: string;
  path: string;
  perspective?: string;
  dataset?: string;
  projectId?: string;
  tool?: string;
  type?: string;
  workspace?: string;
};
/**
 * Data resolved from a Sanity Stega node
 * @public
 */
type SanityStegaNode = {
  origin: string;
  href: string;
  data?: unknown;
};
interface DocumentSchema {
  type: 'document';
  name: string;
  title?: string;
  icon?: string;
  fields: Partial<Record<string, SchemaObjectField>>;
}
interface TypeSchema {
  type: 'type';
  name: string;
  title?: string;
  value: SchemaNode;
}
type SchemaType = DocumentSchema | TypeSchema;
interface SchemaArrayNode<T extends SchemaNode = SchemaNode> {
  type: 'array';
  of: SchemaArrayItem<T>;
}
interface SchemaArrayItem<T extends SchemaNode = SchemaNode> {
  type: 'arrayItem';
  name: string;
  title?: string;
  value: T;
}
interface SchemaBooleanNode {
  type: 'boolean';
  value?: boolean;
}
interface SchemaInlineNode {
  type: 'inline';
  /** the name of the referenced type */
  name: string;
}
interface SchemaNullNode {
  type: 'null';
}
interface SchemaNumberNode {
  type: 'number';
  value?: number;
}
interface SchemaObjectNode<T extends SchemaNode = SchemaNode> {
  type: 'object';
  fields: Partial<Record<string, SchemaObjectField<T>>>;
  rest?: SchemaObjectNode | SchemaUnknownNode | SchemaInlineNode;
  dereferencesTo?: string;
}
interface SchemaObjectField<T extends SchemaNode = SchemaNode> {
  type: 'objectField';
  name: string;
  title?: string;
  value: T;
  optional?: boolean;
}
interface SchemaStringNode {
  type: 'string';
  value?: string;
}
type SchemaUnionNodeOptions = Omit<ArrayOptions, 'insertMenu'> & {
  insertMenu?: Omit<InsertMenuOptions, 'views'> & {
    views?: Array<{
      name: 'list';
    } | {
      name: 'grid';
      previewImageUrls?: Record<string, string | undefined>;
    }>;
  };
};
interface SchemaUnionNode<T extends SchemaNode = SchemaNode> {
  type: 'union';
  of: SchemaUnionOption<T>[] | SchemaStringNode[] | SchemaNumberNode[];
  options?: SchemaUnionNodeOptions;
}
interface SchemaUnionOption<T extends SchemaNode = SchemaNode> {
  type: 'unionOption';
  name: string;
  title?: string;
  icon?: string;
  value: T;
}
interface SchemaUnknownNode {
  type: 'unknown';
}
type SchemaNode = SchemaArrayNode | SchemaBooleanNode | SchemaInlineNode | SchemaNullNode | SchemaNumberNode | SchemaObjectNode | SchemaStringNode | SchemaUnionNode | SchemaUnknownNode;
type ResolvedSchemaTypeMap = Map<string, Map<string, StudioPathLike>>;
interface UnresolvedPath {
  id: string;
  path: string;
}
/**
 * @public
 */
type PreviewSnapshot = { [K in keyof Omit<PreviewValue, 'media'>]?: Omit<PreviewValue, 'media'>[K] } & {
  _id: string;
};
export { DocumentSchema, type InsertMenuOptions, type Path, PreviewSnapshot, ResolvedSchemaTypeMap, SanityNode, SanityStegaNode, SchemaArrayItem, SchemaArrayNode, SchemaBooleanNode, SchemaInlineNode, SchemaNode, SchemaNullNode, SchemaNumberNode, SchemaObjectField, SchemaObjectNode, SchemaStringNode, SchemaType, SchemaUnionNode, SchemaUnionNodeOptions, SchemaUnionOption, SchemaUnknownNode, TypeSchema, UnresolvedPath };
//# sourceMappingURL=index.d.ts.map