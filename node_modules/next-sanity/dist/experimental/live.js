import { t as sanitizePerspective } from "../utils.js";
import { n as PUBLISHED_SYNC_TAG_PREFIX, t as DRAFT_SYNC_TAG_PREFIX } from "../constants.js";
import { perspectiveCookieName } from "@sanity/preview-url-secret/constants";
import { cookies, draftMode } from "next/headers";
import { stegaEncodeSourceMap } from "@sanity/client/stega";
import { jsx } from "react/jsx-runtime";
import "server-only";
import { createClient } from "next-sanity";
import SanityLiveClientComponent from "next-sanity/experimental/client-components/live";
import { cacheLife, cacheTag, updateTag } from "next/cache";
import { preconnect } from "react-dom";
async function resolvePerspectiveFromCookies({ cookies: jar }) {
	return jar.has(perspectiveCookieName) ? sanitizePerspective(jar.get(perspectiveCookieName)?.value, "drafts") : "drafts";
}
async function sanityCachedFetch(config, { query, params = {}, perspective, stega, requestTag, draftToken, customCacheTags = [] }) {
	"use cache: remote";
	const client = createClient({
		...config,
		useCdn: true
	});
	const useCdn = perspective === "published";
	const { result, resultSourceMap, syncTags } = await client.fetch(query, params, {
		filterResponse: false,
		returnQuery: false,
		perspective,
		useCdn,
		resultSourceMap: stega ? "withKeyArraySelector" : void 0,
		stega: false,
		cacheMode: useCdn ? "noStale" : void 0,
		tag: requestTag,
		token: perspective === "published" ? config.token : draftToken || config.token
	});
	const tags = [...customCacheTags, ...(syncTags || []).map((tag) => `${perspective === "published" ? PUBLISHED_SYNC_TAG_PREFIX : DRAFT_SYNC_TAG_PREFIX}${tag}`)];
	cacheTag(...tags);
	cacheLife({ revalidate: 3600 * 24 * 90 });
	return {
		data: result,
		sourceMap: resultSourceMap || null,
		tags
	};
}
function defineLive(config) {
	const { client: _client, serverToken, browserToken } = config;
	if (!_client) throw new Error("`client` is required for `defineLive` to function");
	if (process.env.NODE_ENV !== "production" && !serverToken && serverToken !== false) console.warn("No `serverToken` provided to `defineLive`. This means that only published content will be fetched and respond to live events. You can silence this warning by setting `serverToken: false`.");
	if (process.env.NODE_ENV !== "production" && !browserToken && browserToken !== false) console.warn("No `browserToken` provided to `defineLive`. This means that live previewing drafts will only work when using the Presentation Tool in your Sanity Studio. To support live previewing drafts stand-alone, provide a `browserToken`. It is shared with the browser so it should only have Viewer rights or lower. You can silence this warning by setting `browserToken: false`.");
	const client = _client.withConfig({
		allowReconfigure: false,
		useCdn: false
	});
	const { token: originalToken, apiHost, apiVersion, useProjectHostname, dataset, projectId, requestTagPrefix, stega: stegaConfig } = client.config();
	return {
		sanityFetch: function sanityFetch({ query, params = {}, stega = false, perspective = "published", tags: customCacheTags = [], requestTag = "next-loader.fetch" }) {
			return sanityCachedFetch({
				apiHost,
				apiVersion,
				useProjectHostname,
				dataset,
				projectId,
				requestTagPrefix,
				token: originalToken
			}, {
				query,
				params,
				perspective,
				stega,
				requestTag,
				draftToken: serverToken,
				customCacheTags
			}).then(({ data, sourceMap, tags }) => ({
				data: stega && sourceMap ? stegaEncodeSourceMap(data, sourceMap, {
					...stegaConfig,
					enabled: true
				}) : data,
				sourceMap,
				tags
			}));
		},
		SanityLive: function SanityLive(props) {
			const { refreshOnMount = false, refreshOnFocus = false, refreshOnReconnect = false, requestTag, onError, onGoAway, intervalOnGoAway, revalidateSyncTags = expireTags } = props;
			const { projectId: projectId$1, dataset: dataset$1, apiHost: apiHost$1, apiVersion: apiVersion$1, useProjectHostname: useProjectHostname$1, requestTagPrefix: requestTagPrefix$1 } = client.config();
			const { origin } = new URL(client.getUrl("", false));
			preconnect(origin);
			return /* @__PURE__ */ jsx(SanityLiveServerComponent, {
				config: {
					projectId: projectId$1,
					dataset: dataset$1,
					apiHost: apiHost$1,
					apiVersion: apiVersion$1,
					useProjectHostname: useProjectHostname$1,
					requestTagPrefix: requestTagPrefix$1
				},
				requestTag,
				browserToken,
				refreshOnMount,
				refreshOnFocus,
				refreshOnReconnect,
				onError,
				onGoAway,
				intervalOnGoAway,
				revalidateSyncTags,
				resolveDraftModePerspective: props.resolveDraftModePerspective ?? resolveDraftModePerspective
			});
		}
	};
}
const SanityLiveServerComponent = async function SanityLiveServerComponent$1(props) {
	const { config, requestTag, intervalOnGoAway, onError, onGoAway, refreshOnFocus, refreshOnMount, refreshOnReconnect, revalidateSyncTags, browserToken, resolveDraftModePerspective: resolveDraftModePerspective$1 } = props;
	const { isEnabled: isDraftModeEnabled } = await draftMode();
	return /* @__PURE__ */ jsx(SanityLiveClientComponent, {
		config: {
			...config,
			token: typeof browserToken === "string" && isDraftModeEnabled ? browserToken : void 0
		},
		requestTag,
		draftModeEnabled: isDraftModeEnabled,
		refreshOnMount,
		refreshOnFocus,
		refreshOnReconnect,
		onError,
		onGoAway,
		intervalOnGoAway,
		revalidateSyncTags,
		resolveDraftModePerspective: resolveDraftModePerspective$1
	});
};
async function expireTags(_tags) {
	"use server";
	if (!Array.isArray(_tags)) {
		console.warn("<SanityLive /> `expireTags` called with non-array tags", _tags);
		return;
	}
	const tags = _tags.filter((tag) => typeof tag === "string" && tag.startsWith(PUBLISHED_SYNC_TAG_PREFIX));
	if (!tags.length) {
		console.warn("<SanityLive /> `expireTags` called with no valid tags", _tags);
		return;
	}
	for (const tag of tags) updateTag(tag);
	console.log(`<SanityLive /> updated tags: ${tags.join(", ")}`);
}
async function resolveDraftModePerspective() {
	"use server";
	if ((await draftMode()).isEnabled) return resolvePerspectiveFromCookies({ cookies: await cookies() });
	return "published";
}
export { defineLive, resolvePerspectiveFromCookies };

//# sourceMappingURL=live.js.map