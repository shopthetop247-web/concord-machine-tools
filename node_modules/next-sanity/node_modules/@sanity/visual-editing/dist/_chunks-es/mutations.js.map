{"version":3,"file":"mutations.js","sources":["../../../../node_modules/.pnpm/@sanity+util@5.0.0_@types+react@19.2.7_debug@4.4.3/node_modules/@sanity/util/lib/paths.js","../../src/react/useOptimisticActor.ts","../../src/react/useDocuments.ts","../../src/util/randomKey.ts","../../src/util/mutations.ts"],"sourcesContent":["import { isIndexSegment, isKeySegment, isIndexTuple } from \"@sanity/types\";\nconst rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g, reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/, EMPTY_PATH = [], FOCUS_TERMINATOR = \"$\", GROQ_DATA_TYPE_VALUES = [\"true\", \"false\", \"null\"];\nfunction get(obj, path, defaultVal) {\n  const select = typeof path == \"string\" ? fromString(path) : path;\n  if (!Array.isArray(select))\n    throw new Error(\"Path must be an array or a string\");\n  let acc = obj;\n  for (let i = 0; i < select.length; i++) {\n    const segment = select[i];\n    if (isIndexSegment(segment)) {\n      if (!Array.isArray(acc))\n        return defaultVal;\n      acc = acc[segment];\n    }\n    if (isKeySegment(segment)) {\n      if (!Array.isArray(acc))\n        return defaultVal;\n      acc = acc.find((item) => item._key === segment._key);\n    }\n    if (typeof segment == \"string\" && (acc = typeof acc == \"object\" && acc !== null ? acc[segment] : void 0), typeof acc > \"u\")\n      return defaultVal;\n  }\n  return acc;\n}\nconst pathsMemo = /* @__PURE__ */ new Map();\nfunction pathFor(path) {\n  if (path.length === 0)\n    return EMPTY_PATH;\n  const asString = toString(path);\n  return pathsMemo.has(asString) ? pathsMemo.get(asString) : (pathsMemo.set(asString, path), Object.freeze(path), path);\n}\nfunction isEqual(path, otherPath) {\n  return path.length === otherPath.length && path.every((segment, i) => isSegmentEqual(segment, otherPath[i]));\n}\nfunction numEqualSegments(path, otherPath) {\n  const length = Math.min(path.length, otherPath.length);\n  for (let i = 0; i < length; i++)\n    if (!isSegmentEqual(path[i], otherPath[i]))\n      return i;\n  return length;\n}\nfunction isSegmentEqual(segmentA, segmentB) {\n  return isKeySegment(segmentA) && isKeySegment(segmentB) ? segmentA._key === segmentB._key : isIndexSegment(segmentA) ? Number(segmentA) === Number(segmentB) : isIndexTuple(segmentA) && isIndexTuple(segmentB) ? segmentA[0] === segmentB[0] && segmentA[1] === segmentB[1] : segmentA === segmentB;\n}\nfunction hasFocus(focusPath, path) {\n  const withoutTerminator = focusPath[focusPath.length - 1] === FOCUS_TERMINATOR ? focusPath.slice(0, -1) : focusPath;\n  return isEqual(withoutTerminator, path);\n}\nfunction hasItemFocus(focusPath, item) {\n  return focusPath.length === 1 && isSegmentEqual(focusPath[0], item);\n}\nfunction isExpanded(segment, focusPath) {\n  const [head, ...tail] = focusPath;\n  return tail.length > 0 && isSegmentEqual(segment, head);\n}\nfunction startsWith(prefix, path) {\n  return prefix.every((segment, i) => isSegmentEqual(segment, path[i]));\n}\nfunction trimLeft(prefix, path) {\n  if (prefix.length === 0 || path.length === 0)\n    return path;\n  const [prefixHead, ...prefixTail] = prefix, [pathHead, ...pathTail] = path;\n  return isSegmentEqual(prefixHead, pathHead) ? pathFor(trimLeft(prefixTail, pathTail)) : path;\n}\nfunction trimRight(suffix, path) {\n  const sufLen = suffix.length, pathLen = path.length;\n  if (sufLen === 0 || pathLen === 0)\n    return path;\n  let i = 0;\n  for (; i < sufLen && i < pathLen && isSegmentEqual(path[pathLen - i - 1], suffix[sufLen - i - 1]); )\n    i++;\n  return pathFor(path.slice(0, pathLen - i));\n}\nfunction trimChildPath(path, childPath) {\n  return startsWith(path, childPath) ? trimLeft(path, childPath) : EMPTY_PATH;\n}\nfunction toString(path) {\n  if (!Array.isArray(path))\n    throw new Error(\"Path is not an array\");\n  return path.reduce((target, segment, i) => {\n    const isHead = i === 0;\n    if (typeof segment == \"number\")\n      return `${target}[${segment}]`;\n    if (typeof segment == \"string\")\n      return isHead ? segment : GROQ_DATA_TYPE_VALUES.includes(segment) ? `${target}[\"${segment}\"]` : `${target}.${segment}`;\n    if (isKeySegment(segment) && segment._key)\n      return `${target}[_key==\"${segment._key}\"]`;\n    if (Array.isArray(segment)) {\n      const [from, to] = segment;\n      return `${target}[${from}:${to}]`;\n    }\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``);\n  }, \"\");\n}\nfunction _resolveKeyedPath(value, path) {\n  if (path.length === 0)\n    return path;\n  const [next, ...rest] = path;\n  if (typeof next == \"number\") {\n    if (!Array.isArray(value) || !(next in value))\n      return [];\n    const item = value[next];\n    return [typeof item?._key == \"string\" ? { _key: item._key } : next, ..._resolveKeyedPath(item, rest)];\n  }\n  const nextVal = get(value, [next]);\n  return [next, ..._resolveKeyedPath(nextVal, rest)];\n}\nfunction resolveKeyedPath(value, path) {\n  if (!Array.isArray(path))\n    throw new Error(\"Path is not an array\");\n  return pathFor(_resolveKeyedPath(value, path));\n}\nfunction fromString(path) {\n  if (typeof path != \"string\")\n    throw new Error(\"Path is not a string\");\n  const segments = path.match(rePropName);\n  if (!segments)\n    throw new Error(\"Invalid path string\");\n  return segments.map(normalizePathSegment);\n}\nfunction normalizePathSegment(segment) {\n  return isIndexSegment(segment) ? normalizeIndexSegment(segment) : isKeySegment(segment) ? normalizeKeySegment(segment) : isIndexTuple(segment) ? normalizeIndexTupleSegment(segment) : segment;\n}\nfunction normalizeIndexSegment(segment) {\n  return Number(segment.replace(/[^\\d]/g, \"\"));\n}\nfunction normalizeKeySegment(segment) {\n  return { _key: segment.match(reKeySegment)[1] };\n}\nfunction normalizeIndexTupleSegment(segment) {\n  const [from, to] = segment.split(\":\").map((seg) => seg === \"\" ? seg : Number(seg));\n  return [from, to];\n}\nexport {\n  FOCUS_TERMINATOR,\n  _resolveKeyedPath,\n  fromString,\n  get,\n  hasFocus,\n  hasItemFocus,\n  isEqual,\n  isExpanded,\n  isSegmentEqual,\n  numEqualSegments,\n  pathFor,\n  resolveKeyedPath,\n  startsWith,\n  toString,\n  trimChildPath,\n  trimLeft,\n  trimRight\n};\n//# sourceMappingURL=paths.js.map\n","import {useCallback, useMemo, useSyncExternalStore} from 'react'\n\nimport {\n  actor,\n  emptyActor,\n  isEmptyActor,\n  listeners,\n  type EmptyActor,\n  type MutatorActor,\n} from '../optimistic/context'\n\nexport function useOptimisticActor(): MutatorActor | EmptyActor {\n  const subscribe = useCallback((listener: () => void) => {\n    listeners.add(listener)\n    return () => listeners.delete(listener)\n  }, [])\n\n  const actorRef = useSyncExternalStore(\n    subscribe,\n    () => actor,\n    () => emptyActor,\n  )\n\n  return actorRef\n}\n\nexport function useOptimisticActorReady(): boolean {\n  const actor = useOptimisticActor()\n  return useMemo(() => !isEmptyActor(actor), [actor])\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {SanityDocument} from '@sanity/client'\n\nimport {getDraftId, getPublishedId} from '@sanity/client/csm'\nimport {createIfNotExists, patch} from '@sanity/mutate'\nimport {isMaybePreviewIframe, isMaybePreviewWindow} from '@sanity/presentation-comlink'\nimport {get as getAtPath} from '@sanity/util/paths'\nimport {useCallback} from 'react'\n\nimport type {\n  DocumentsGet,\n  DocumentsMutate,\n  OptimisticDocumentPatches,\n  Path,\n  PathValue,\n} from '../optimistic/types'\n\nimport {isEmptyActor, type MutatorActor} from '../optimistic/context'\nimport {useOptimisticActor} from './useOptimisticActor'\n\nfunction debounce<F extends (...args: Parameters<F>) => ReturnType<F>>(fn: F, timeout: number): F {\n  let timer: ReturnType<typeof setTimeout>\n  return ((...args: Parameters<F>) => {\n    clearTimeout(timer)\n    timer = setTimeout(() => {\n      fn.apply(fn, args)\n    }, timeout)\n  }) as F\n}\n\nfunction getDocumentsAndSnapshot<T extends Record<string, any>>(id: string, actor: MutatorActor) {\n  const inFrame = isMaybePreviewIframe()\n  const inPopUp = isMaybePreviewWindow()\n\n  if (isEmptyActor(actor) || (!inFrame && !inPopUp)) {\n    throw new Error('The `useDocuments` hook cannot be used in this context')\n  }\n\n  const draftId = getDraftId(id)\n  const publishedId = getPublishedId(id)\n  const documents = actor.getSnapshot().context?.documents\n\n  const draftDoc = documents?.[draftId]\n  const publishedDoc = documents?.[publishedId]\n  const doc = draftDoc || publishedDoc\n\n  if (!doc) {\n    throw new Error(`Document \"${id}\" not found`)\n  }\n\n  // Helper to get the snapshot from the draft document if it exists, otherwise\n  // fall back to the published document\n  const getDocumentSnapshot = () =>\n    (draftDoc.getSnapshot().context?.local || publishedDoc.getSnapshot().context?.local) as\n      | SanityDocument<T>\n      | null\n      | undefined\n\n  const snapshot = getDocumentSnapshot()\n  const snapshotPromise = new Promise<SanityDocument<T> | null>((resolve) => {\n    if (snapshot) {\n      resolve(snapshot)\n    } else {\n      const subscriber = doc.on('ready', (event) => {\n        // Assert type here as the original document mutator machine doesn't\n        // emit a 'ready' event. We provide a custom action to emit it in this\n        // package's internal `createDatasetMutator` function. <3 xstate.\n        const {snapshot} = event as unknown as {snapshot: SanityDocument<T> | null | undefined}\n        resolve(snapshot || null)\n        subscriber.unsubscribe()\n      })\n    }\n  })\n\n  const getSnapshot = () => snapshotPromise\n\n  return {\n    draftDoc,\n    draftId,\n    getSnapshot,\n    publishedDoc,\n    publishedId,\n    /**\n     * @deprecated - use `getSnapshot` instead\n     */\n    get snapshot() {\n      // Maintain original error throwing behaviour, to avoid breaking changes\n      if (!snapshot) {\n        throw new Error(`Snapshot for document \"${id}\" not found`)\n      }\n      return snapshot\n    },\n  }\n}\n\nfunction createDocumentCommit<T extends Record<string, any>>(id: string, actor: MutatorActor) {\n  return (): void => {\n    const {draftDoc} = getDocumentsAndSnapshot<T>(id, actor)\n    draftDoc.send({type: 'submit'})\n  }\n}\n\n/**\n * @deprecated - superseded by `createDocumentGetSnapshot`\n */\nfunction createDocumentGet<T extends Record<string, any>>(id: string, actor: MutatorActor) {\n  return <P extends Path<T, keyof T>>(\n    path?: P,\n  ): PathValue<T, P> | SanityDocument<T> | undefined => {\n    const {snapshot} = getDocumentsAndSnapshot<T>(id, actor)\n\n    return path\n      ? (getAtPath(snapshot, path) as PathValue<T, P>)\n      : (snapshot as unknown as SanityDocument<T>)\n  }\n}\n\nfunction createDocumentGetSnapshot<T extends Record<string, any>>(\n  id: string,\n  actor: MutatorActor,\n): () => Promise<SanityDocument<T> | null> {\n  const {getSnapshot} = getDocumentsAndSnapshot<T>(id, actor)\n  return getSnapshot\n}\n\nfunction createDocumentPatch<T extends Record<string, any>>(id: string, actor: MutatorActor) {\n  return async (\n    patches: OptimisticDocumentPatches<T>,\n    options?: {commit?: boolean | {debounce: number}},\n  ): Promise<void> => {\n    // Destructure the function result in two steps as we need access to the\n    // `result.snapshot` property in the getter, but don't want to execute the\n    // getter prematurely as it may throw\n    const result = getDocumentsAndSnapshot<T>(id, actor)\n    const {draftDoc, draftId, getSnapshot, publishedId} = result\n\n    const {commit = true} = options || {}\n\n    const context = {\n      draftId,\n      publishedId,\n      /**\n       * @deprecated - use `getSnapshot` instead\n       */\n      get snapshot() {\n        return result.snapshot\n      },\n      getSnapshot,\n    }\n\n    const resolvedPatches = await (typeof patches === 'function' ? patches(context) : patches)\n\n    const _snapshot = await getSnapshot()\n\n    if (!_snapshot) {\n      throw new Error(`Snapshot for document \"${id}\" not found`)\n    }\n\n    draftDoc.send({\n      type: 'mutate',\n      mutations: [\n        // Attempt to create the draft document, it might not exist if the\n        // snapshot was from the published document\n        createIfNotExists({..._snapshot, _id: draftId}),\n        // Patch the draft document with the resolved patches\n        patch(draftId, resolvedPatches),\n      ],\n    })\n\n    if (commit) {\n      if (typeof commit === 'object' && 'debounce' in commit) {\n        const debouncedCommit = debounce(() => draftDoc.send({type: 'submit'}), commit.debounce)\n        debouncedCommit()\n      } else {\n        draftDoc.send({type: 'submit'})\n      }\n    }\n  }\n}\n\nexport function useDocuments(): {\n  getDocument: DocumentsGet\n  mutateDocument: DocumentsMutate\n} {\n  const actor = useOptimisticActor() as MutatorActor\n\n  const getDocument: DocumentsGet = useCallback(\n    <T extends Record<string, any>>(documentId: string) => {\n      return {\n        id: documentId,\n        commit: createDocumentCommit(documentId, actor),\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore - Type instantiation is excessively deep and possibly infinite.\n        get: createDocumentGet(documentId, actor),\n        getSnapshot: createDocumentGetSnapshot<T>(documentId, actor),\n        patch: createDocumentPatch<T>(documentId, actor),\n      }\n    },\n    [actor],\n  )\n\n  const mutateDocument: DocumentsMutate = useCallback(\n    (id, mutations, options) => {\n      const {draftDoc} = getDocumentsAndSnapshot(id, actor)\n      const {commit = true} = options || {}\n\n      draftDoc.send({\n        type: 'mutate',\n        mutations: mutations,\n      })\n\n      if (commit) {\n        if (typeof commit === 'object' && 'debounce' in commit) {\n          const debouncedCommit = debounce(() => draftDoc.send({type: 'submit'}), commit.debounce)\n          debouncedCommit()\n        } else {\n          draftDoc.send({type: 'submit'})\n        }\n      }\n    },\n    [actor],\n  )\n\n  return {getDocument, mutateDocument}\n}\n","// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  crypto.getRandomValues(rnds8)\n  return rnds8\n}\n\nconst getByteHexTable = (() => {\n  let table: string[]\n  return () => {\n    if (table) {\n      return table\n    }\n    table = []\n    for (let i = 0; i < 256; ++i) {\n      table[i] = (i + 0x100).toString(16).slice(1)\n    }\n    return table\n  }\n})()\n\nexport function randomKey(length?: number): string {\n  const table = getByteHexTable()\n  return whatwgRNG(length)\n    .reduce((str, n) => str + table[n], '')\n    .slice(0, length)\n}\n","import type {SanityDocument} from '@sanity/client'\nimport type {SanityNode} from '@sanity/presentation-comlink'\n\nimport {at, insert, truncate, type NodePatchList} from '@sanity/mutate'\nimport {get} from '@sanity/util/paths'\n\nimport type {OptimisticDocument} from '../optimistic/types'\n\nimport {randomKey} from './randomKey'\n\nexport function getArrayItemKeyAndParentPath(pathOrNode: string | SanityNode): {\n  path: string\n  key: string\n  hasExplicitKey: boolean\n} {\n  const elementPath = typeof pathOrNode === 'string' ? pathOrNode : pathOrNode.path\n\n  const lastDotIndex = elementPath.lastIndexOf('.')\n  const lastPathItem = elementPath.substring(lastDotIndex + 1, elementPath.length)\n\n  if (!lastPathItem.indexOf('[')) throw new Error('Invalid path: not an array')\n\n  const lastArrayIndex = elementPath.lastIndexOf('[')\n  const path = elementPath.substring(0, lastArrayIndex)\n\n  let key\n  let hasExplicitKey\n\n  if (lastPathItem.includes('_key')) {\n    // explicit [_key=\"...\"]\n\n    const startIndex = lastPathItem.indexOf('\"') + 1\n    const endIndex = lastPathItem.indexOf('\"', startIndex)\n\n    key = lastPathItem.substring(startIndex, endIndex)\n\n    hasExplicitKey = true\n  } else {\n    // indexes [int]\n    const startIndex = lastPathItem.indexOf('[') + 1\n    const endIndex = lastPathItem.indexOf(']', startIndex)\n\n    key = lastPathItem.substring(startIndex, endIndex)\n\n    hasExplicitKey = false\n  }\n\n  if (!path || !key) throw new Error('Invalid path')\n\n  return {\n    path,\n    key,\n    hasExplicitKey,\n  }\n}\n\nexport function getArrayDuplicatePatches(\n  node: SanityNode,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  snapshot: SanityDocument<Record<string, any>>,\n  position: 'before' | 'after' = 'after',\n): NodePatchList {\n  const {path: arrayPath, key: itemKey} = getArrayItemKeyAndParentPath(node)\n\n  const item = get(snapshot, node.path) as object\n  const duplicate = {...item, _key: randomKey()}\n\n  return [at(arrayPath, insert(duplicate, position, {_key: itemKey}))]\n}\n\nexport function getArrayRemovePatches(\n  node: SanityNode,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  snapshot: SanityDocument<Record<string, any>>,\n): NodePatchList {\n  const {path: arrayPath, key: itemKey} = getArrayItemKeyAndParentPath(node)\n  const array = get(snapshot, arrayPath) as {_key: string}[]\n  const currentIndex = array.findIndex((item) => item._key === itemKey)\n  return [at(arrayPath, truncate(currentIndex, currentIndex + 1))]\n}\n\nexport function getArrayInsertPatches(\n  node: SanityNode,\n  insertType: string,\n  position: 'before' | 'after',\n): NodePatchList {\n  const {path: arrayPath, key: itemKey} = getArrayItemKeyAndParentPath(node)\n  const insertKey = randomKey()\n  const referenceItem = {_key: itemKey}\n  return [at(arrayPath, insert([{_type: insertType, _key: insertKey}], position, referenceItem))]\n}\n\nexport async function getArrayMovePatches(\n  node: SanityNode,\n  doc: OptimisticDocument,\n  moveTo: 'previous' | 'next' | 'first' | 'last',\n): Promise<NodePatchList> {\n  if (!node.type) throw new Error('Node type is missing')\n  const {path: arrayPath, key: itemKey} = getArrayItemKeyAndParentPath(node)\n\n  const snapshot = await doc.getSnapshot()\n  const array = get(snapshot, arrayPath) as {_key: string}[]\n  const item = get(snapshot, node.path)\n  const currentIndex = array.findIndex((item) => item._key === itemKey)\n\n  let nextIndex = -1\n  let position: 'before' | 'after' = 'before'\n\n  if (moveTo === 'first') {\n    if (currentIndex === 0) return []\n    nextIndex = 0\n    position = 'before'\n  } else if (moveTo === 'last') {\n    if (currentIndex === array.length - 1) return []\n    nextIndex = -1\n    position = 'after'\n  } else if (moveTo === 'next') {\n    if (currentIndex === array.length - 1) return []\n    nextIndex = currentIndex\n    position = 'after'\n  } else if (moveTo === 'previous') {\n    if (currentIndex === 0) return []\n    nextIndex = currentIndex - 1\n    position = 'before'\n  }\n\n  return [\n    at(arrayPath, truncate(currentIndex, currentIndex + 1)),\n    at(arrayPath, insert(item, position, nextIndex)),\n  ]\n}\n"],"names":["rePropName","reKeySegment","get","obj","path","defaultVal","select","fromString","Array","isArray","Error","acc","i","length","segment","isIndexSegment","isKeySegment","find","item","_key","segments","match","map","normalizePathSegment","normalizeIndexSegment","normalizeKeySegment","isIndexTuple","normalizeIndexTupleSegment","Number","replace","from","to","split","seg","useOptimisticActor","useSyncExternalStore","_temp","_temp2","_temp3","emptyActor","actor","listener","listeners","add","delete","useOptimisticActorReady","$","_c","t0","isEmptyActor","debounce","fn","timeout","timer","args","clearTimeout","setTimeout","apply","getDocumentsAndSnapshot","id","inFrame","isMaybePreviewIframe","inPopUp","isMaybePreviewWindow","draftId","getDraftId","publishedId","getPublishedId","documents","getSnapshot","context","draftDoc","publishedDoc","doc","snapshot","local","snapshotPromise","Promise","resolve","subscriber","on","event","unsubscribe","createDocumentCommit","send","type","createDocumentGet","getAtPath","createDocumentGetSnapshot","createDocumentPatch","patches","options","result","commit","resolvedPatches","_snapshot","mutations","createIfNotExists","_id","patch","useDocuments","documentId","getDocument","t1","t2","undefined","mutateDocument","whatwgRNG","rnds8","Uint8Array","crypto","getRandomValues","getByteHexTable","table","toString","slice","randomKey","reduce","str","n","getArrayItemKeyAndParentPath","pathOrNode","elementPath","lastDotIndex","lastIndexOf","lastPathItem","substring","indexOf","lastArrayIndex","key","hasExplicitKey","includes","startIndex","endIndex","getArrayDuplicatePatches","node","position","arrayPath","itemKey","duplicate","at","insert","getArrayRemovePatches","currentIndex","findIndex","truncate","getArrayInsertPatches","insertType","insertKey","_type","getArrayMovePatches","moveTo","array","nextIndex"],"mappings":"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","x_google_ignoreList":[0]}